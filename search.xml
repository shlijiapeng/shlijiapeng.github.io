<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Ros]]></title>
      <url>http://www.shlijiapeng.com/2016/05/13/ros/</url>
      <content type="html"><![CDATA[<h1 id="Ros概述"><a href="#Ros概述" class="headerlink" title="Ros概述"></a>Ros概述</h1><h2 id="历史概述"><a href="#历史概述" class="headerlink" title="历史概述"></a>历史概述</h2><p>　　伴随科学技术发展，人工智能的需求日益增长，机器人领域也迅速发展，响应需求，Willow Garage公司于2010年发布了开源机器人操作系统Ros。<br>　　Ros英文全称为robot operating system。如其名，其主要用于硬件抽象描述、底层驱动程序管理、共用功能的执行、程序间的消息传递、程序发行包管理，具体表现如动态导航壁障、手臂抓取物品、图像识别等。作为开源系统，其汇集众多社区贡献者项目代码，遵循于BSD许可。<br><a id="more"></a></p>
<h2 id="现状概述"><a href="#现状概述" class="headerlink" title="现状概述"></a>现状概述</h2><p>　　目前Ros已在机器人研究领域掀起热潮。以robocup大赛为例，国内许多参赛队伍机器人导航模块采用此系统。中科大“可佳”机器人曾于去年夺得国际赛冠军，不例外，他们也采用ros系统，可见ros潜力可观。 </p>
<h1 id="Ros原理概述"><a href="#Ros原理概述" class="headerlink" title="Ros原理概述"></a>Ros原理概述</h1><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>　　Ros文件系统主要以包为主，功能程序打包成包以模块形式独立运行。建立包时添加依赖、导入ros官方库或开源包，扩展程序功能模块。包通过CMake编译系统编译，可以在pakage.xml中自行定制编译细节。包的层次结构可见图1.</p>
<p><center> <img src="http://img.blog.csdn.net/20151118155215448" alt="图１"><br>图1</center></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>　　堆是包的集合，它提供一个完整的功能。</p>
<h2 id="计算图级"><a href="#计算图级" class="headerlink" title="计算图级"></a>计算图级</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>　　节点即为程序模块，可视作ros程序的基础组成模块。各个节点作为线程独立运行，执行不同操作，通过通讯传输数据。</p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>　　节点之间通过消息通讯。消息所采用的数据结构既可以是C语言所支持的数据结构，也可以是ros内置的数据结构，如导航模块所需的geometry/Twist数据类型，更可以是自定义的数据结构。</p>
<h3 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h3><p>　　消息通过发布/订阅的方式传播，节点发布消息到话题，另一节点订阅话题，即可以获取消息。可见图2.<br>　<center> <img src="http://img.blog.csdn.net/20151118155400364" alt="这里写图片描述"><br>图2</center></p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>　　服务好比web服务器，采取请求/回应模式传输数据。相比于话题的广播式发布数据，服务节点通信信道是唯一的，也由此简化节点设计。</p>
<h3 id="Actionlib"><a href="#Actionlib" class="headerlink" title="Actionlib"></a>Actionlib</h3><p>　　Actionlib实时反馈数据，支持高级数据处理与节点设计模式。</p>
<h1 id="Ros安装"><a href="#Ros安装" class="headerlink" title="Ros安装"></a>Ros安装</h1><p>　　Ros推荐运行于ubuntu操作系统，安装方法可参照官网教程。<br>由于其对于图像处理有一定要求，所以计算棒、树莓派等简单计算机并不能胜任工作。</p>
<h1 id="Ros简易指南"><a href="#Ros简易指南" class="headerlink" title="Ros简易指南"></a>Ros简易指南</h1><h2 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h2><p>　　创建工作空间以在其内创建软件包。</p>
<h2 id="Rviz"><a href="#Rviz" class="headerlink" title="Rviz"></a>Rviz</h2><p>　　Ros可视化工具，将地图数据、激光数据、点云数据可视化表现。支持用户自行配置以及保存配置信息。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code>catkin_init_workspace：初始化工作空间
catkin_make：编译软件包
rospack find:寻找软件包
roscore：运行ros内核
rosrun:运行节点
roslaunch：运行launch文件
rostopic pub:发布消息至话题
rosrun rqt…:rqt命令集提供一系列可视化工具
</code></pre><h2 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h2><pre><code>geometry/Twist:包含线速度、角速度数据，用以下发底盘速度。
sensor_msgs/Laser_scan：激光数据类型
scansor_msgs/PointClouod:点云数据类型
</code></pre><h2 id="Launch文件"><a href="#Launch文件" class="headerlink" title="Launch文件"></a>Launch文件</h2><p>　　Launch文件支持。其实际为xml所定义的格式化语言，通过launch文件，可以同时启动多个结点、读入参数等等。</p>
<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><h2 id="导航架构"><a href="#导航架构" class="headerlink" title="导航架构"></a>导航架构</h2><p>　　导航涉及底盘运动、实时避障等。其中又可分为坐标系系统、传感器模块、里程计模块、底盘控制、地图服务等。<br>　　要充分利用导航堆，需要合理配置各个模块，针对机器人硬件适配与优化。</p>
<h2 id="Navigation-stack"><a href="#Navigation-stack" class="headerlink" title="Navigation stack"></a>Navigation stack</h2><h3 id="Global、Local"><a href="#Global、Local" class="headerlink" title="Global、Local"></a>Global、Local</h3><p>　　全局规划负责路径规划，本地规划则负责局部实时规划。<br>　　设定目标点后，全局负责规划路径，遇见障碍物或者局部地图产生变化时，本地负责分析并重新规划合理路径。</p>
<h3 id="Costmap"><a href="#Costmap" class="headerlink" title="Costmap"></a>Costmap</h3><p>　　导航堆用costmap储存障碍物信息。</p>
<h3 id="Recovery-behaviors"><a href="#Recovery-behaviors" class="headerlink" title="Recovery_behaviors"></a>Recovery_behaviors</h3><p>　　导航过程中难免产生误差，当导航模块计算得规划数据和实际数据存在误差，便会采取修复行为来修复tf坐标系数据。<br>　　修复行为可分为：rotate_recovery和clear_costmap_recovery。<br>    Rotate_recovery:旋转360度以清理costmap<br>    Clear_costmap_recovery:移动至原地点一定距离外借以清理costmap</p>
<h3 id="Cmd-vel"><a href="#Cmd-vel" class="headerlink" title="Cmd_vel"></a>Cmd_vel</h3><p>　　导航模块下发速度时常用话题名。</p>
<h3 id="Map-sever"><a href="#Map-sever" class="headerlink" title="Map_sever"></a>Map_sever</h3><p>　　地图服务采用像素点匹配模式，即实时数据和地图数据进行像素点匹配。因此，必要时可以使用photoshop修改地图，模拟障碍物信息。</p>
<h3 id="Amcl"><a href="#Amcl" class="headerlink" title="Amcl"></a>Amcl</h3><p>　　机器人的二维移动概率定位系统。</p>
<p><center> <img src="http://img.blog.csdn.net/20151118155432821" alt="这里写图片描述"><br>图3</center></p>
<h2 id="Tf坐标系"><a href="#Tf坐标系" class="headerlink" title="Tf坐标系"></a>Tf坐标系</h2><p>　　机器人由各个组件组成，如激光、底盘、里程计、手臂。Ros中需要为各个组件建立独立坐标系，再通过tf系统转换各个坐标系，而base_link则作为坐标系中心。见图4<br> <img src="http://img.blog.csdn.net/20151118155459731" alt="这里写图片描述"><br>图4<br>　　建立tf树以建立合适的tf坐标系，可见图5。<br>　　各个独立坐标系通过tf树建立互相联系，tf坐标系既可为机器人定位，也可为各组件有序运动助力。<br>  <center> <img src="http://img.blog.csdn.net/20151118155522639" alt="这里写图片描述"><br>图5</center></p>
<h2 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h2><h3 id="激光数据"><a href="#激光数据" class="headerlink" title="激光数据"></a>激光数据</h3><p>　　激光数据主要用于二维导航。所需传感器为激光，使用数据类型为senor_msgs/LaserScan。</p>
<h3 id="点云数据"><a href="#点云数据" class="headerlink" title="点云数据"></a>点云数据</h3><p>　　点云提供三维世界数据，主要用于建立三维地图。Kinect等传感器支持点云数据输入，使用数据类型为senor_msgs/PointCloud。</p>
<h2 id="底盘控制"><a href="#底盘控制" class="headerlink" title="底盘控制"></a>底盘控制</h2><p>　　底盘是机器人最重要的组件之一，运动控制器、里程计、电机等基础组件都包含在底盘中。而同时，若底盘不能够正常运作，上层许多功能都无法正常服务。<br>　　适配底盘也即是将cmd_vel数据类型转换成驱动器解析需求的数据类型，再由驱动器控制电机转动，完成底盘运动。</p>
<h2 id="里程计"><a href="#里程计" class="headerlink" title="里程计"></a>里程计</h2><p>　　里程计返回里程数据，传递给里程计坐标系。</p>
<h1 id="Pluginlib"><a href="#Pluginlib" class="headerlink" title="Pluginlib"></a>Pluginlib</h1><p>　　编写插件以配置nav core的修复行为，costmap误差较大时，合理采取修复行为以抵达目标点。</p>
<h1 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h1><p>　　正确配置IDE，则可以在IDE中编写及调试ros程序。<br>　　c、c++推荐使用eclipse，python推荐使用pycharm。</p>
<blockquote>
<p>引用块内容<br><a href="http://blog.csdn.net/hcx25909/article/category/1191901" target="_blank" rel="external">http://blog.csdn.net/hcx25909/article/category/1191901</a><br><a href="http://blog.csdn.net/lanhuadechenmo" target="_blank" rel="external">http://blog.csdn.net/lanhuadechenmo</a><br>wiki.ros.org</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C#概述]]></title>
      <url>http://www.shlijiapeng.com/2016/05/12/Introductiontocsharp/</url>
      <content type="html"><![CDATA[<p>选修课结课论文，just for fun.<br><a id="more"></a></p>
<h2 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h2><h3 id="面向过程程序设计的来由"><a href="#面向过程程序设计的来由" class="headerlink" title="面向过程程序设计的来由"></a>面向过程程序设计的来由</h3><p>　　要解释面向对象程序设计，都应当将其与面向过程程序设计作对比。<br>　　面向过程程序设计往往是流程化的，以机械式思维来解决问题，同时要求程序员的思维模式偏向硬件，从机械的角度来考虑如何一步步解决问题。<br>然而随着计算机科学、网络以及信息技术的发展，这种编程思维越发力不从心。这意味着在开发大型软件项目时，面向过程程序设计往往显得力不从心，程序员不得不开发一个个模块来完成功能，代码复用率低下、研发周期长、软件工作效率低下等等。<br>　　因此为了适应现代社会对软件开发的更高需求，面向对象程序设计作为解决方案而兴起。<br>　　面向对象的核心思想为万物皆对象。这种思想十分接近于人类思维方式，而不像面向过程程序设计那样程序员不得不从机器的角度来思考问题。<br>　　同时面向对象导入了类与对象的思想。类就是特定拥有共同属性、特征的对象的集合，对象则是类的实例，它实现了类的属性、特征等等。这和现实世界中是非常贴近的，比如鸟可以作为一种类，而乌鸦和喜鹊都可以作为鸟类的对象，他们共同拥有鸟类的属性——翅膀、飞翔等等。然而它们之间却也有不同的属性，比如乌鸦拥有全黑的羽毛，而喜鹊却不是，这就涉及到继承与子类了。<br>　　由此，面向对象程序设计产生并且不断发展壮大，成为或不可缺的一部分。</p>
<h3 id="典型的面向对象语言"><a href="#典型的面向对象语言" class="headerlink" title="典型的面向对象语言"></a>典型的面向对象语言</h3><p>　　Java/c#/Python等等。众多编程语言或者设计之初已支持面向对象特性，又或者后来在更新面向对象特性。而如今在高等编程中，掌握面向对象特性已经或不可缺，编程语言对于面向对象的支持度又决定了其性能。</p>
<h3 id="面向对象编程语言的展望"><a href="#面向对象编程语言的展望" class="headerlink" title="面向对象编程语言的展望"></a>面向对象编程语言的展望</h3><p> 　　从目前来看，作为程序员必须掌握一门面向对象编程语言，同时IT界技术不断发展，类似于F#、Docker等技术不断涌出，以及互联网的风靡，不少程序员更加青睐于类似于javascript、java、python等对网络支持性良好的语言，然而这一切都脱离不了面向对象思想，因为万物皆对象。</p>
<h2 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>　　在面向对象程序设计中有个重要概念——继承不得不提。同时其存在也极为增加了代码可重用性，简化了软件开发过程。<br>　　被继承的类成为父类、基类，继承的类成为子类、派生类。子类可以继承拥有权限的父类的变量、方法、访问器等等，然而在其基础上扩展类的定义。子类还可以重写和覆盖父类的方法，而这也是面向对象的多态性的体现。<br>　　首先由继承就可知存在访问修饰符，它们分别为internal、public、protected、private。</p>
<pre><code>public：访问不受限制。
protected：访问仅限于包含类或从包含类派生的类型。
Internal：访问仅限于当前程序集。
protected internal：访问仅限于当前程序集或从包含类派生的类型。
private：访问仅限于包含类型。
其中还有特殊的两类：sealed和virtual。
Sealed所修饰的类无法作为基类被继承。
Virtual可用于修饰需要被重写的方法等等。
</code></pre><p>　　接下来用一些C#示例来说明继承特性。</p>
<pre><code>namespace temp
{
    class animalClass
    {
        public class animal
        {
            public int number;
            int Number
            {
                set { this.number = value; }
                get { return this.number; }
            }

        public animal(int num)
        {
            this.number = num;
            Console.WriteLine(&quot;Create animal&quot;);
        }

        public void animfun()
        {
            Console.WriteLine(&quot;Function of animal&quot;);
            Console.WriteLine(&quot;Number of animal is {0}&quot;, number);
        }

        virtual public void virtualfun()
        {
            Console.WriteLine(&quot;Don&apos;t do it!&quot;);
        }
    }

    public class bird:animal
    {
        public string colour;
        string Colour
        {
            set { this.colour = value; }
            get { return this.colour; }
        }

        public bird(int num,string col):base(num)
        {
            this.colour=col;
        }

        public void birdfun()
        {
            Console.WriteLine(&quot;Function of bird&quot;);
            Console.WriteLine(&quot;number of bird is {0} and colour of bird is {1}&quot;, number, colour);
        }

        public override void virtualfun()
        {
            Console.WriteLine(&quot;Change it!&quot;);
        }
    }
}
</code></pre><p>}</p>
<p>　　以上为animal和bird的定义。</p>
<pre><code>namespace temp
{
    class Program
    {
        static void Main(string[] args)
        {
            animalClass.bird bir = new animalClass.bird(19, &quot;blue&quot;);
            bir.birdfun();
        }
    }
}
</code></pre><p>　　如上实例化bird类的对象bir之后在调用birdfun可得结果：</p>
<pre><code>Create animal
Function of bird
number of bird is 19 and colour of bird is blue
</code></pre><p>　　可见bird类的确继承了来自animal类的number字段并且拥有了自己的属性——用于储存colcur的字符串。同时可以调用animal类的animfun函数和bird类的birdfun函数。</p>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>　　面向对象程序设计用经常涉及子类继承父类，就如乌鸦是鸟类的一个对象一样，鸟类抽象出了乌鸦和喜鹊共同的属性。同时由此我们可以引入面向对象中的另一个概念——抽象。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>　　在C#中接口就是抽象的一种，它可以要求继承自其的类必须实现其中的方法，提供一种统一的标准来实现类。</p>
<pre><code>namespace temp
{
    public interface Interface1
    {
        void fun();
    }
}
</code></pre><p>　　示例中定义一个名为Interface1的接口，其中它要求实现无返回值的fun方法。</p>
<pre><code>namespace temp
{
    class fromInterface1 :Interface1
    {
        public void fun()
        {
            Console.WriteLine(&quot;This is fun&quot;);
        }
    }
}
</code></pre><p>　　类fromInterface1则继承自Interface1，因此倘若不实现fun方法，编译器就会报错。如：error CS0535: “temp.fromInterface1”不实现接口成员“temp.Interface1.fun()”。</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>C#中抽象还有另一种实现方式——抽象类以及抽象方法。</p>
<pre><code>namespace temp
{
    class @abstract
    {
        abstract class num1
        {
            abstract public void fun();
        }

        class num2 : num1
        {
            public override void fun()
            {
                Console.WriteLine(&quot;Do it!&quot;);
            }
        }
    }
}
</code></pre><p>　　同继承自抽象接口，子类继承抽象类中的抽象方法时，必须重写抽象方法，否则编译器会报错，无法通过编译。<br>　　同时抽象类也有着其特征，不能从抽象类实例化对象，同时子类也必须实现抽象类中所有抽象方法。如同示例中所示范，用关键词override来重写抽象方法。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>　　多态是一种面向对象程序设计中的概念。多态为程序设计提供了灵活性、变通性与多样性。<br>　　在C#中多态可以体现为函数重载、抽象类、重写函数。</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><pre><code>class simpleSample
{
    public simpleSample(int n)
    {
        Console.WriteLine(&quot;Create simpleSample and this is 1&quot;);
    }

    public simpleSample(int n,int m)
    {
        Console.WriteLine(&quot;Create simpleSample and this is 2&quot;);
    }
}
</code></pre><p>　　当以语句simpleSample sam = new simpleSample(1)实例化时，输出Create simpleSample and this is 1<br>　　当以语句simpleSample sam = new simpleSample(1,2)实例化时，输出Create simpleSample and this is 2<br>　　可见相同的函数，当调用时传入参数不同时，可以完成不同的功能，这就是函数重载。</p>
<h4 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h4><p>　　重写函数在抽象一节中已经出现示例。只有用virtual、abstract、override定义的函数才能重写。通过重写函数、继承抽象类，可以以相同的函数、形式完成不同的功能，这就是多态的本质之一。<br>　　多态为面向对象程序设计重要特性之一，也即同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>　　封装的定义为隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读取和修改的访问级别。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>　　在C#中可以用属性对进行封装。属性可以分为get和set访问器，由此可以将字段设置为可读、可写或可读写，同时不仅如此，还可在访问器中进行操作来完成需求。<br>    定义如下：</p>
<pre><code>class simpleSample2
{
    public int number;
    public int Number
    {
        get{return this.number;}
        set { this.number = value; }
    }

public int number2;
public int Number2
{
    set { this.number2 = value + 1; }
    get {return this.number2;}
}

public simpleSample2()
{
    Console.WriteLine(&quot;Create simpleSample2&quot;);
}
</code></pre><p>}<br>　　主程序如下：</p>
<pre><code>    simpleSample2 sam = new simpleSample2();
    sam.Number = 1;
    sam.Number2 = 1;
Console.WriteLine(&quot;number={0} and number2={1}&quot;, sam.number, sam.number2);
</code></pre><p>　　结果如下：</p>
<pre><code>Create simpleSample2
number=1 and number2=2
</code></pre><p>　　可见通过set访问器可在访问字段时进行操作，同时通过设置读写权限完成封装操作。</p>
<h4 id="接口和权限修饰符"><a href="#接口和权限修饰符" class="headerlink" title="接口和权限修饰符"></a>接口和权限修饰符</h4><p>　　封装就是对代码、程序进行保护。通过权限修饰符保护代码的可访问性，再提供接口，用户在不清楚实现细节的基础上就可以使用代码，完成了封装效果。<br>　　具体过程一般就是从类中抽象出函数原型再组成C#中Interface，就完成了提供接口。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://www.shlijiapeng.com/2016/05/12/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
